#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEditor;
using UnityEditor.Compilation;
using UnityEngine;
using Assembly = System.Reflection.Assembly;

namespace Shware.Netcode
{
    [InitializeOnLoad]
    public static class AutoSerializableCodeGen
    {
        private const string GeneratedDir = "Assets/AutoSerializable/Generated";
        private const string AutoAttrName = "Shware.Netcode.AutoSerializableAttribute";
        private const string IgnoreAttrName = "Shware.Netcode.IgnoreSerializableAttribute";

        static AutoSerializableCodeGen()
        {
            // Unity가 .cs들을 컴파일해서 .dll 만든 “직후”에 불리는 이벤트.
            CompilationPipeline.compilationFinished += _ =>
            {
                //다음 프레임에 안전하게 Generate 실행
                EditorApplication.delayCall -= Generate;
                EditorApplication.delayCall += Generate;
            };
        }

        [MenuItem("Tools/Shware/Generate AutoSerializable")]
        public static void Generate()
        {
            Directory.CreateDirectory(GeneratedDir);

            // 기존 생성 파일 목록(절대경로) 저장 -> 이번에 재생성 못한 건 stale로 삭제
            var existingFiles = new HashSet<string>(
                Directory.GetFiles(GeneratedDir, "*.AutoSerializable.g.cs")
                    .Select(Path.GetFullPath));

            foreach (var asm in GetUserAssemblies())
            {
                Type[] types;
                try
                {
                    types = asm.GetTypes();
                }
                catch (ReflectionTypeLoadException e)
                {
                    types = e.Types.Where(t => t != null).ToArray();
                }

                foreach (var t in types)
                {
                    if (!t.IsValueType || t.IsEnum) continue;

                    var autoAttr = t.GetCustomAttributes(false)
                                        .FirstOrDefault(a => a.GetType().FullName == AutoAttrName);
                    if (autoAttr == null) continue;

                    if (!IsPartialStruct(t))
                    {
                        Debug.LogError($"[AS001] Struct must be partial: {t.FullName}");
                        continue;
                    }

                    if (HasManualNetworkSerialize(t))
                    {
                        Debug.LogError($"[AS002] NetworkSerialize already exists: {t.FullName}");
                        continue;
                    }

                    bool generateEquatable = GetGenerateEquatable(autoAttr);

                    bool hasError = false;
                    var fields = new List<FieldInfo>();
                    foreach (var f in t.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic |
                                                  BindingFlags.DeclaredOnly))
                    {
                        if (f.IsStatic || f.IsLiteral) continue;
                        if (f.IsNotSerialized) continue;
                        if (HasIgnoreSerializable(f)) continue;

                        if (!f.FieldType.IsValueType)
                        {
                            Debug.LogError($"[AS003] Reference type not supported: {t.FullName}.{f.Name}");
                            hasError = true;
                            break;
                        }
                        fields.Add(f);
                    }
                    if (hasError) continue;
                    
                    if (fields.Count == 0) continue;

                    var source = GenerateSource(t, fields, generateEquatable);
                    var fileName = MakeSafeFileName(t.FullName);
                    var path = Path.GetFullPath(Path.Combine(GeneratedDir, $"{fileName}.AutoSerializable.g.cs"));

                    File.WriteAllText(path, source, new UTF8Encoding(false));
                    existingFiles.Remove(path);
                }
            }

            foreach (var stale in existingFiles)
                File.Delete(stale);
            AssetDatabase.Refresh();
        }

        private static string MakeSafeFileName(string fullName)
        {
            return fullName.Replace('.', '_').Replace('+', '_');
        }

        private static string GenerateSource(Type type, List<FieldInfo> fields, bool generateEquatable)
        { 
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            
            //namespace가 있으면
            if(!string.IsNullOrEmpty(type.Namespace))
            {
                sb.AppendLine($"namespace {type.Namespace}");
                sb.AppendLine("{");
            }

            sb.Append($"public partial struct {type.Name} : Unity.Netcode.INetworkSerializable");
            if (generateEquatable) 
                sb.Append($", System.IEquatable<{type.Name}>");
            sb.AppendLine();
            sb.AppendLine("{");

            //NetworkSerializable
            sb.AppendLine("    public void NetworkSerialize<T>(Unity.Netcode.BufferSerializer<T> serializer)");
            sb.AppendLine("        where T : Unity.Netcode.IReaderWriter");
            sb.AppendLine("    {");
            foreach(var field in fields)
            {
                sb.AppendLine($"        serializer.SerializeValue(ref {field.Name});");
            }
            sb.AppendLine("    }");

            if(generateEquatable)
            {

                //Equals<T>
                sb.AppendLine();
                sb.AppendLine($"    public bool Equals({type.Name} other)");
                sb.AppendLine("    {");
                if (fields.Count == 1)
                {
                    var f = fields[0].Name;
                    sb.AppendLine($"        return {f}.Equals(other.{f});");
                }
                else
                {
                    sb.AppendLine("        return " +
                                  string.Join(" && ", fields.Select(f => $"{f.Name}.Equals(other.{f.Name})")) +
                                  ";");
                }
                
                sb.AppendLine("    }");

                // Equals(object)
                sb.AppendLine();
                sb.AppendLine("    public override bool Equals(object obj)");
                sb.AppendLine("    {");
                sb.AppendLine($"        return obj is {type.Name} other && Equals(other);");
                sb.AppendLine("    }");

                // GetHashCode
                sb.AppendLine();
                sb.AppendLine("    public override int GetHashCode()");
                sb.AppendLine("    {");
                sb.AppendLine(
                    $"        return System.HashCode.Combine({string.Join(", ", fields.Select(f => f.Name))});"
                    );
                sb.AppendLine("    }");
            }

            sb.AppendLine("}");

            if (!string.IsNullOrEmpty(type.Namespace))
            { sb.AppendLine("}"); }

            return sb.ToString();
        }

        private static bool HasIgnoreSerializable(FieldInfo fieldInfo)
        {
            return fieldInfo.GetCustomAttributes(false).Any(a => a.GetType().FullName == IgnoreAttrName);
        }


        private static bool GetGenerateEquatable(object autoAttr)
        {
            var prop = autoAttr.GetType().GetProperty("GenerateEquatable");
            return prop == null || (bool)prop.GetValue(autoAttr);
        }

        private static bool HasManualNetworkSerialize(Type type)
        {
            return type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly)
                .Any(m => m.Name == "NetworkSerialize");
        }

        private static bool IsPartialStruct(Type type)
        {
            var scripts = AssetDatabase.FindAssets("t:Script")
                .Select(AssetDatabase.GUIDToAssetPath)
                .Where(p => p.EndsWith(".cs"));

            foreach (var path in scripts)
            {
                var text = File.ReadAllText(path);
                if (!text.Contains(type.Name)) continue;

                if (text.Contains($"partial struct {type.Name}") ||
                    text.Contains($"readonly partial struct {type.Name}") ||
                    text.Contains($"partial readonly struct {type.Name}"))
                    return true;
            }

            return false;
        }
        

        private static IEnumerable<Assembly> GetUserAssemblies()
        {
            return AppDomain.CurrentDomain.GetAssemblies()
                .Where(a =>
                {
                    var n = a.GetName().Name;
                    if (string.IsNullOrEmpty(n)) return false;
                    if (n.StartsWith("Unity")) return false;
                    if (n.StartsWith("System")) return false;
                    if (n.StartsWith("mscorlib")) return false;
                    if (n.StartsWith("netstandard")) return false;
                    return true;
                });
        }
    }
}
#endif
